# .github/workflows/PlaylistsOptimizedEnhanced.yml
# Nome do workflow que aparecerÃ¡ na interface do GitHub Actions
# Este nome serÃ¡ exibido na aba "Actions" do repositÃ³rio
name: "ðŸ“‹ Listas de ReproduÃ§Ã£o Otimizadas (AtualizaÃ§Ã£o AutomÃ¡tica)"

# Define os eventos que irÃ£o disparar a execuÃ§Ã£o deste workflow
on:
  # ConfiguraÃ§Ã£o do agendamento automÃ¡tico do workflow
  schedule:
  # Agenda a execuÃ§Ã£o diÃ¡ria ao meia-noite (12:00) no horÃ¡rio UTC
  # A sintaxe usa padrÃ£o cron com 5 campos (minuto hora dia mÃªs dia-da-semana)
    - cron: '0 3 * * *'
      timezone: 'America/Fortaleza'  # Usa o mesmo fuso que BrasÃ­lia (UTC-3)
  # ExplicaÃ§Ã£o detalhada da sintaxe cron:
  # - '0'    - no minuto 0 (em ponto)
  # - '3'   - Ã s 3 horas UTC (que equivalem a 0h em Fortaleza)
  # - '*'    - todos os dias do mÃªs
  # - '*'    - todos os meses do ano
  # - '*'    - todos os dias da semana (de domingo a sÃ¡bado)
  
  # ObservaÃ§Ãµes importantes:
  # 1. O horÃ¡rio Ã© sempre em UTC (Tempo Universal Coordenado)
  # 2. O GitHub pode atrasar em atÃ© 15 minutos a execuÃ§Ã£o agendada
  # 3. O workflow nÃ£o serÃ¡ executado se nÃ£o houver alteraÃ§Ãµes no repositÃ³rio,
  #    a menos que vocÃª configure para rodar sempre

  # Permite acionar manualmente o workflow atravÃ©s da interface do GitHub
  # AparecerÃ¡ um botÃ£o "Run workflow" na interface Actions
  workflow_dispatch:

# Configura as permissÃµes necessÃ¡rias para este workflow
permissions:
  # PermissÃ£o para escrever no repositÃ³rio (necessÃ¡rio para fazer commits)
  # NÃ­vel de permissÃ£o: write (escrita)
  contents: write

# Lista de jobs (tarefas) que serÃ£o executados como parte deste workflow
jobs:
  # Primeiro job - responsÃ¡vel por baixar e processar as playlists
  # Identificador modificado (sem emoji para evitar problemas)
  download_playlists:
    # Nome amigÃ¡vel que serÃ¡ exibido na interface (pode conter emoji)
    name: "ðŸ“¥ Download e processamento"
    
    # Define o sistema operacional onde o job serÃ¡ executado
    # ubuntu-latest = versÃ£o mais recente do Ubuntu disponÃ­vel
    runs-on: ubuntu-latest

    # Lista de passos (etapas) que serÃ£o executados sequencialmente
    steps:
      # ================================
      # Passo 1: Fazer checkout (clonar) do repositÃ³rio
      # ================================
      - name: "ðŸ”½ Checkout do repositÃ³rio"
        # Usa a aÃ§Ã£o oficial do GitHub para checkout (versÃ£o 4)
        uses: actions/checkout@v4
        with:
          # ConfiguraÃ§Ã£o de seguranÃ§a: nÃ£o persistir credenciais
          persist-credentials: false
          # Baixa todo o histÃ³rico de commits (necessÃ¡rio para operaÃ§Ãµes git posteriores)
          # 0 = baixa todo o histÃ³rico
          fetch-depth: 0

      # ================================
      # Passo 2: Configurar o ambiente Python
      # ================================
      - name: "ðŸ Configurar Python"
        # Usa a aÃ§Ã£o oficial de setup do Python (versÃ£o 4)
        uses: actions/setup-python@v4
        with:
          # Define a versÃ£o especÃ­fica do Python a ser usada (3.8)
          python-version: '3.8'

      # ================================
      # Passo 3: Configurar cache para dependÃªncias pip
      # ================================
      # Isso acelera execuÃ§Ãµes futuras ao reutilizar pacotes jÃ¡ baixados
      - name: "ðŸ“¦ Cache de dependÃªncias pip"
        # Usa a aÃ§Ã£o oficial de cache (versÃ£o 3)
        uses: actions/cache@v3
        with:
          # Caminho onde o pip armazena os pacotes baixados
          path: ~/.cache/pip
          # Chave Ãºnica para o cache baseada em:
          # - Sistema operacional (runner.os)
          # - Hash do arquivo requirements.txt (se existir)
          key: ${{ runner.os }}-pip-${{ hashFiles('**/requirements.txt') }}
          # Chaves alternativas para tentar restaurar o cache
          # caso a chave principal nÃ£o exista
          restore-keys: |
            ${{ runner.os }}-pip-

      # ================================
      # Passo 4: Instalar dependÃªncias Python necessÃ¡rias
      # ================================
      - name: "âš™ï¸ Instalar dependÃªncias"
        # Comandos que serÃ£o executados no shell
        run: |
          # Atualiza o pip para a versÃ£o mais recente
          python -m pip install --upgrade pip
          # Instala o pacote requests (necessÃ¡rio para os scripts)
          pip install requests

      # ================================
      # Passo 5: Executar o primeiro script Python (playlists2.py)
      # ================================
      - name: "â–¶ï¸ Executar playlists2.py"
        # Comando para executar o script Python
        run: python playlists2.py
      
      # ================================
      # Passo 6: Executar o segundo script Python (playlists.py)
      # ================================
      - name: "â–¶ï¸ Executar playlists.py"
        run: python playlists.py
      
      # ================================
      # Passo 7: Executar o terceiro script Python (Playlist.py)
      # ================================
      - name: "â–¶ï¸ Executar Playlist.py"
        run: python Playlist.py
      
      # ================================
      # Passo 8: Adicionar timestamp nos arquivos gerados
      # ================================
      - name: "â±ï¸ Adicionar data/hora nos arquivos"
        run: |
          # Loop por todos os arquivos .m3u e .xml.gz no diretÃ³rio raiz
          # -maxdepth 1 = procura apenas no diretÃ³rio atual
          # -type f = apenas arquivos (nÃ£o diretÃ³rios)
          # -name "*.m3u" -o -name "*.xml.gz" = arquivos com essas extensÃµes
          for file in $(find . -maxdepth 1 -type f -name "*.m3u" -o -name "*.xml.gz"); do
            # Adiciona um comentÃ¡rio com a data/hora atual:
            # - TZ='America/Fortaleza' = define o fuso horÃ¡rio (BRT)
            # date '+%d/%m/%Y - %H:%M:%S' = formato da data
            # >> "$file" = adiciona ao final do arquivo
            echo -e "\n\n# Atualizado em $(TZ='America/Fortaleza' date '+%d/%m/%Y - %H:%M:%S') BRT" >> "$file"
          done

      # ================================
      # Passo 9: Verificar se houve alteraÃ§Ãµes nos arquivos
      # ================================
      - name: "ðŸ” Verificar alteraÃ§Ãµes no Git"
        # Define um ID para referenciar este passo posteriormente
        id: git_status
        run: |
          # Verifica se hÃ¡ mudanÃ§as nÃ£o commitadas:
          # git status --porcelain = formato simplificado para scripts
          # O if verifica se a saÃ­da nÃ£o estÃ¡ vazia (-n)
          if [[ -n "$(git status --porcelain .)" ]]; then
            # Se houver mudanÃ§as, define uma variÃ¡vel de ambiente 'changes' como true
            # $GITHUB_ENV = arquivo especial onde variÃ¡veis de ambiente sÃ£o definidas
            echo "changes=true" >> $GITHUB_ENV
          else
            # Se nÃ£o houver mudanÃ§as, define como false
            echo "changes=false" >> $GITHUB_ENV
          fi

      # ================================
      # Passo 10: Fazer commit e push das alteraÃ§Ãµes (se houver mudanÃ§as)
      # ================================
      - name: "ðŸ’¾ Salvar alteraÃ§Ãµes no GitHub"
        # Condicional - sÃ³ executa se houver mudanÃ§as (changes == 'true')
        if: env.changes == 'true'
        # Define variÃ¡veis de ambiente especÃ­ficas para este passo
        env:
          # Usa um token de acesso pessoal armazenado nos secrets do repositÃ³rio
          # secrets.MY_PAGES_GITHUB_TOKEN = nome do segredo que contÃ©m o token
          GITHUB_TOKEN: ${{ secrets.MY_PAGES_GITHUB_TOKEN }}
        run: |
          # Configura o usuÃ¡rio do git (necessÃ¡rio para fazer commits)
          git config --global user.name "github-actions[bot]"
          git config --global user.email "github-actions[bot]@users.noreply.github.com"
          
          # Adiciona todos os arquivos modificados ao staging area
          git add .
          
          # Cria um commit com uma mensagem padrÃ£o
          git commit -m "ðŸ”„ AtualizaÃ§Ã£o automÃ¡tica dos arquivos baixados"
          
          # Faz pull das alteraÃ§Ãµes remotas (se houver) para evitar conflitos
          # --no-rebase = evita rebase automÃ¡tico
          # || true = ignora erros (caso nÃ£o haja alteraÃ§Ãµes remotas)
          git pull origin main --no-rebase || true
          
          # Faz push das alteraÃ§Ãµes para o repositÃ³rio:
          # Usa o token de autenticaÃ§Ã£o (GITHUB_TOKEN)
          # ${{ github.repository }} = nome do repositÃ³rio (ex: usuario/repo)
          git push https://x-access-token:${GITHUB_TOKEN}@github.com/${{ github.repository }}.git main

      # ================================
      # Passo 11: Listar arquivos gerados (Ãºtil para debug)
      # ================================
      - name: "ðŸ“‚ Listar arquivos gerados"
        # Comando para listar todos os arquivos no diretÃ³rio atual
        # -la = formato longo, mostra todos os arquivos (incluindo ocultos)
        run: ls -la

      # ================================
      # Passo 12: Mensagem de sucesso (executa apenas se todos os passos anteriores foram bem sucedidos)
      # ================================
      - name: "âœ… Tudo certo!"
        # Condicional - sÃ³ executa se o workflow foi bem sucedido atÃ© este ponto
        if: success()
        # Simples mensagem no log
        run: echo "Workflow executado com sucesso!"

      # ================================
      # Passo 13: Mensagem de falha (executa apenas se algum passo anterior falhou)
      # ================================
      - name: "âŒ Ops, algo deu errado!"
        # Condicional - sÃ³ executa se houve falha em algum passo anterior
        if: failure()
        # Mensagem de erro no log
        run: echo "Workflow falhou!"

# .github/workflows/Playlists.yaml
name: "ðŸ“‹ Listas de ReproduÃ§Ã£o Otimizadas (AtualizaÃ§Ã£o AutomÃ¡tica)"

on:
  schedule:
    - cron: '0 3 * * *'
      timezone: 'America/Fortaleza'
  workflow_dispatch:

permissions:
  contents: write

jobs:
  download_playlists:
    name: "ðŸ“¥ Download e processamento"
    runs-on: ubuntu-latest

    steps:
      - name: "ðŸ”½ Checkout do repositÃ³rio (com token)"
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          fetch-depth: 0

      - name: "ðŸ Configurar Python"
        uses: actions/setup-python@v4
        with:
          python-version: '3.8'

      - name: "âš™ï¸ Instalar dependÃªncias"
        run: |
          python -m pip install --upgrade pip
          pip install requests

      - name: "â–¶ï¸ Executar scripts"
        run: |
          python playlists2.py
          python playlists.py
          python Playlist.py

      - name: "â±ï¸ Adicionar data/hora nos arquivos"
        run: |
          for file in $(find . -maxdepth 1 -type f -name "*.m3u" -o -name "*.xml.gz"); do
            echo -e "\n\n# Atualizado em $(TZ='America/Fortaleza' date '+%d/%m/%Y - %H:%M:%S') BRT" >> "$file"
          done

      - name: "ðŸ” Verificar alteraÃ§Ãµes"
        id: check-changes
        run: |
          git status --porcelain
          if [ -n "$(git status --porcelain)" ]; then
            echo "changes_detected=true" >> $GITHUB_OUTPUT
          else
            echo "changes_detected=false" >> $GITHUB_OUTPUT
          fi

      - name: "ðŸ’¾ Commit e push das alteraÃ§Ãµes"
        if: steps.check-changes.outputs.changes_detected == 'true'
        run: |
          git config --global user.name "github-actions[bot]"
          git config --global user.email "41898282+github-actions[bot]@users.noreply.github.com"
          git add .
          git commit -m "ðŸ”„ AtualizaÃ§Ã£o automÃ¡tica - $(date +'%d/%m/%Y %H:%M')"
          git pull
          git push
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: "âœ… Status final"
        run: |
          if [ "${{ steps.check-changes.outputs.changes_detected }}" = "true" ]; then
            echo "AlteraÃ§Ãµes foram commitadas e enviadas com sucesso!"
          else
            echo "Nenhuma alteraÃ§Ã£o detectada - nada para commit."
          fi
